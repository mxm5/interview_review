# JAVA ENVIRONMENT

The Java environment includes various technologies that are important to understand for Java development. The Java Development Kit (JDK) is a key component that contains the minimum software required for Java development. The JDK includes several key commands, such as javac, java, jar, and javadoc. These commands are used for converting Java source files into bytecode, executing the program, packaging files together, and generating documentation.

The bytecode generated by the javac command is executed by the Java Virtual Machine (JVM). The JVM is a special magic box on your machine that understands how to run bytecode on the specific operating system and hardware it is running on.

Java 8 and earlier versions included the Java Runtime Environment (JRE), which was a subset of the JDK used for running Java programs. However, with the current version of Java, developers can use the full JDK to run Java programs, and an executable can be created that contains the necessary pieces that would have been included in the JRE.

Java also includes a suite of APIs that developers can use to access common functionality and algorithms. For example, the StringBuilder class can be used to create a large string, and the Collections method can be used to sort a list.

While the JDK includes the minimum software required for Java development, many developers use an integrated development environment (IDE) to make writing and running code easier. Common Java IDEs include Eclipse, IntelliJ IDEA, and Visual Studio Code. However, it is not recommended to use an IDE while studying for the Java exam.

# sum
---

JRE used to be in older versions of java
now the minimum requirement to run java is jdc
java : compile byte code
javac : run byte code
javadoc : documentation
jar : packaging
java api: like stringbuilder collections
ide dont use
___
# Understanding theÂ Class Structure
In Java, a class is a blueprint or a template that defines the properties and behavior of an object. It specifies what data the object will store, and what operations can be performed on the object. An object is an instance of a class, which is created at runtime and occupies memory. In other words, a class defines a set of attributes and methods that an object of that class will have, while an object is an actual instance of that class with its own unique state and behavior. To use most classes, you have to create objects. An object is a runtime instance of a class in memory. An object is often referred to as an instance since it represents a single representation of the class. All the various objects of all the different classes represent the state of your program. A reference is a variable that points to an object.

# SUM
---
class blueprint
behaviour and properties
type date store
operations to do
object instance class runtime in memory
diferent class object repersent state of program
___
# Writing a main() Method

This text is a beginner's guide to creating a Java program that contains a main method, which is the starting point of a program. It includes details on how to create a main method, compile and execute the program, and pass parameters to the main method. The text also explains the rules and requirements for a Java program's main method, such as access modifiers and the static keyword, and how to handle parameters with an array of Strings. The text is aimed at beginners who are just starting with Java programming.
# SUM
___
to compile a program
```shell
javac Zoo.java 
java Zoo
```
how to create main method
main methods args and method can be `final`
```shell
javac Zoo.java 
java Zoo Bronx Zoo
```
with space in the string
```shell
javac Zoo.java 
java Zoo "San Diego" Zoo
```
single line compiling
```shell
java Zoo.java Bronx Zoo
```
having `.java` extenstion shorthand for testing
___
# Understanding Package Declarations and Imports
To summarize, in Java, classes are organized into `logical groupings` called packages. To use a class from a package, you need` to import it` using an import statement, which tells Java where to look for the class. If you don't include the import statement for a class you're using in your code, you'll get a "cannot find symbol" error at compile time. There are two types of import statements in Java: regular import statements and static import statements. Regular import statements are used to import classes, interfaces, and enums, while static import statements are used to import static members of a class.
___
class grouping = package
use from pkg import = tells where find
else cannot find symbol
static import = static members class
regular import = all calss iface enums
___
### package
A package in Java is a way of organizing classes. It is similar to a file cabinet, where you put related pieces of paper in folders. Java packages group related classes together in a logical way. When you compile a Java program, you need to tell the compiler which packages to look in to find code. This is done using the import statement.

Package names in Java are hierarchical, like the `address of a building`. The top level is the country, and the package name starts with a `website name in reverse` order. For example, com.wiley.javabook tells us that the code is associated with the wiley.com website or organization, and the package name com.wiley.java.my.name is a child package of com.wiley.javabook.

Package names are mostly letters or numbers separated by `periods` (.). You can use other characters between the periods, but it's not common. The exam may use package names that don't follow this convention, but they will still be valid package names.

In addition to importing specific classes, you can also use wildcards to import all the classes in a package. This can save time and make your code easier to read. However, it can also lead to naming conflicts, where two classes have the same name in different packages. To avoid this, you can use the fully qualified class name to refer to a specific class.

You can also create your own packages in Java. To do this, you need to use the package declaration at the top of your source file, followed by the class definition. When you compile your code, you need to make sure that the file structure matches the package structure.

Finally, it's important to note that the exam may format code in a specific way to test your understanding of package declarations and imports. It may use different package names, import statements, or naming conventions to test your ability to read and understand code.
# SUM
___
pkg address like building post address
package name rules
wildcard imports all
naming conflict = use full qualified name
create package = file structre match + write package x.y.z 
___
### Wildcards

The text discusses importing classes in Java and how to use a shortcut to import all the classes in a package. It explains that importing a package with a wildcard matches all classes in the package and that only classes directly under the package are imported, not child packages, fields, or methods. The text gives an example of importing java.util.Random and other classes using a wildcard and how to import a specific class, such as AtomicInteger in the java.util.concurrent.atomic package. The article notes that including many classes does not slow down program execution, and it's a personal preference on how to list the imported classes.

---
# sum
all the packages togather = *
importing too much not slow
if you want import a class = full qualified name without class

---
### Redundant Imports

The text explains the concept of importing classes in Java, which allows programmers to reference classes from other packages in their code. It describes the syntax of import statements, how to use wildcards to import multiple classes, and the special behavior of the `java.lang` package, which is automatically imported. The text also covers cases of redundancy and how to handle them, as well as examples of imports that won't work.

---
# SUM
how to use correct name for the folder which package exists in 

---
### Naming Conflict
The text explains how packages help to avoid naming conflicts in Java, and how to handle cases where multiple packages contain classes with the same name. It suggests using explicit imports or wildcards to import specific classes or packages, respectively, and explains how to handle conflicts when importing multiple classes with the same name. In cases where two classes with the same name need to be used, the solution is to use the fully qualified class name.

---
# SUM
